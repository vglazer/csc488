!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.2.2	//
ADD	machineDef.h	/^	POPN,     DUP,   DUPN, BR,    BF,   NEG,    ADD,  SUB,$/;"	e	enum:InstructionCodes
ADDR	machineDef.h	/^	HALT = 0, ADDR,  LOAD, STORE, PUSH, PUSHMT, SETD, POP,    $/;"	e	enum:InstructionCodes
ASTtype	ast.h	/^typedef  void *  ASTtype ;$/;"	t
Args	astDef.h	/^} Args ;$/;"	t
ArgsP	astDef.h	/^typedef struct Args_tag   * ArgsP ;     \/* Arguments    *\/$/;"	t
Args_tag	astDef.h	/^typedef struct Args_tag {$/;"	s
BEGIN	scanner.c	80;"	d	file:
BF	machineDef.h	/^	POPN,     DUP,   DUPN, BR,    BF,   NEG,    ADD,  SUB,$/;"	e	enum:InstructionCodes
BISON	Makefile	/^BISON = bison$/;"	m
BISONFLAGS	Makefile	/^BISONFLAGS = --debug --file-prefix=parser --defines --verbose$/;"	m
BISON_PARSER_TAB_H	parser.tab.h	2;"	d
BOOL	parser.tab.c	9;"	d	file:
BOOL	parser.tab.h	24;"	d
BOOLEAN	common.h	26;"	d
BR	machineDef.h	/^	POPN,     DUP,   DUPN, BR,    BF,   NEG,    ADD,  SUB,$/;"	e	enum:InstructionCodes
CC	Makefile	/^CC = gcc$/;"	m
CFILES	Makefile	/^CFILES = main.c scanner.c parser.tab.c semantics.c codegen.c symbol.c machine.c ast.c astDump.c$/;"	m
CFLAGS	Makefile	/^CFLAGS = -g $/;"	m
DCNAME	astDump.c	103;"	d	file:
DCarray	ast.h	/^  DCarray ,     \/* array                                *\/$/;"	e	enum:DclType_tag
DCfunc	ast.h	/^  DCfunc ,      \/* function                             *\/$/;"	e	enum:DclType_tag
DCnone	ast.h	/^  DCnone ,      \/* unknown                              *\/$/;"	e	enum:DclType_tag
DCproc	ast.h	/^  DCproc        \/* procedure                            *\/$/;"	e	enum:DclType_tag
DCscalar	ast.h	/^  DCscalar ,    \/* scalar variable                      *\/$/;"	e	enum:DclType_tag
DEFAULT_DUMP_FILE	astTest.c	11;"	d	file:
DEFAULT_DUMP_FILE	main.c	100;"	d	file:
DEFAULT_ERROR_FILE	main.c	99;"	d	file:
DEFAULT_INPUT_FILE	main.c	97;"	d	file:
DEFAULT_OUTPUT_FILE	main.c	98;"	d	file:
DEFAULT_RUN_INPUT_FILE	main.c	102;"	d	file:
DEFAULT_TRACE_FILE	main.c	101;"	d	file:
DESC	astTest.c	/^void DESC(char * msg)$/;"	f
DISPLAYSIZE	machineDef.h	63;"	d
DISPLAY_TOP	machine.c	256;"	d	file:
DIV	machineDef.h	/^	MUL,	  DIV,   EQ,   LT,    OR,   SWAP,   READC,PRINTC, $/;"	e	enum:InstructionCodes
DO	parser.tab.c	10;"	d	file:
DO	parser.tab.h	25;"	d
DUP	machineDef.h	/^	POPN,     DUP,   DUPN, BR,    BF,   NEG,    ADD,  SUB,$/;"	e	enum:InstructionCodes
DUPN	machineDef.h	/^	POPN,     DUP,   DUPN, BR,    BF,   NEG,    ADD,  SUB,$/;"	e	enum:InstructionCodes
DataType	ast.h	/^} DataType;$/;"	t
DataType_tag	ast.h	/^typedef enum DataType_tag {$/;"	g
Dbool	ast.h	/^  Dbool,        \/* boolean                              *\/$/;"	e	enum:DataType_tag
DclType	ast.h	/^} DclType;$/;"	t
DclType_tag	ast.h	/^typedef enum DclType_tag {$/;"	g
DeclObj	astDef.h	/^} DeclObj;$/;"	t
DeclP	astDef.h	/^typedef struct Decl_tag   * DeclP ;     \/* Declarations *\/$/;"	t
Decl_tag	astDef.h	/^typedef struct Decl_tag {$/;"	s
Dint	ast.h	/^  Dint ,        \/* integer                              *\/$/;"	e	enum:DataType_tag
Dnone	ast.h	/^  Dnone ,       \/* unknown                              *\/$/;"	e	enum:DataType_tag
Dtext	ast.h	/^  Dtext ,       \/* text( string )                       *\/$/;"	e	enum:DataType_tag
Dvoid	ast.h	/^  Dvoid         \/* void ( procedure )                   *\/$/;"	e	enum:DataType_tag
ECHO	scanner.c	552;"	d	file:
ELSE	parser.tab.c	11;"	d	file:
ELSE	parser.tab.h	26;"	d
EOB_ACT_CONTINUE_SCAN	scanner.c	105;"	d	file:
EOB_ACT_END_OF_FILE	scanner.c	106;"	d	file:
EOB_ACT_LAST_MATCH	scanner.c	107;"	d	file:
EQ	machineDef.h	/^	MUL,	  DIV,   EQ,   LT,    OR,   SWAP,   READC,PRINTC, $/;"	e	enum:InstructionCodes
EXIT	parser.tab.c	12;"	d	file:
EXIT	parser.tab.h	27;"	d
EXTERN_GLOBALS	astTest.c	6;"	d	file:
EXTERN_GLOBALS	globalvars.h	18;"	d
EXTERN_GLOBALS	main.c	51;"	d	file:
EXTERN_MACHINE	machine.c	21;"	d	file:
EXTERN_MACHINE	machineDef.h	83;"	d
EalreadyDeclared	semantics.c	/^    EalreadyDeclared,       \/* variable already declared        *\/$/;"	e	file:
EarrayOutOfBound	semantics.c	/^    EarrayOutOfBound,       \/* declared size of array too large *\/$/;"	e	file:
Ebinary	ast.h	/^  Ebinary,      \/* binary operator                      *\/$/;"	e	enum:ExpnType_tag
Econd	ast.h	/^  Econd ,       \/* conditional expression               *\/$/;"	e	enum:ExpnType_tag
Econst	ast.h	/^  Econst ,      \/* constant                             *\/$/;"	e	enum:ExpnType_tag
EdeclAfterStatement	semantics.c	/^    EdeclAfterStatement,    \/* declaration after statement ( DEBUG ) *\/$/;"	e	file:
EemptyScope	semantics.c	/^    EemptyScope,            \/* scope has no statements ( DEBUG )  *\/$/;"	e	file:
EemptyTree	semantics.c	/^    EemptyTree,             \/* tree is empty  ( DEBUG )           *\/$/;"	e	file:
EexpectedSubscript	semantics.c	/^    EexpectedSubscript,     \/* array variable not subscripted   *\/$/;"	e	file:
Efcall	ast.h	/^  Efcall,       \/* function call                        *\/$/;"	e	enum:ExpnType_tag
EillegalAssignment	semantics.c	/^    EillegalAssignment,     \/* illegal assignment               *\/$/;"	e	file:
EillegalSubscripting	semantics.c	/^    EillegalSubscripting,   \/* non-array variable subscripted   *\/$/;"	e	file:
EintegerOutOfRange	semantics.c	/^    EintegerOutOfRange,     \/* literal integer is out of range  *\/$/;"	e	file:
EinvalidControl	semantics.c	/^    EinvalidControl,        \/* conditional control not boolean  *\/$/;"	e	file:
EinvalidExit	semantics.c	/^    EinvalidExit,           \/* exit occurs outside a loop       *\/$/;"	e	file:
EinvalidExpnType	semantics.c	/^    EinvalidExpnType,       \/* expression used improperly       *\/ $/;"	e	file:
EinvalidGetArgs	semantics.c	/^    EinvalidGetArgs,        \/* invalid get argument             *\/$/;"	e	file:
EinvalidPutArgs	semantics.c	/^    EinvalidPutArgs,        \/* invalid put argument             *\/$/;"	e	file:
EinvalidResult	semantics.c	/^    EinvalidResult,         \/* result occurs outside function   *\/$/;"	e	file:
EinvalidReturn	semantics.c	/^    EinvalidReturn,         \/* return occurs outside procedure  *\/$/;"	e	file:
EinvalidReturnType	semantics.c	/^    EinvalidReturnType,     \/* function return type is invalid  *\/$/;"	e	file:
EinvalidScalarType	semantics.c	/^    EinvalidScalarType,     \/* illegal scalar type ( DEBUG )      *\/$/;"	e	file:
EmissingResult	semantics.c	/^    EmissingResult,         \/* function missing result statment *\/$/;"	e	file:
Enone	ast.h	/^  Enone ,       \/* None, unknown                        *\/$/;"	e	enum:ExpnType_tag
EparamCount	semantics.c	/^    EparamCount,            \/* parameter count                  *\/             $/;"	e	file:
Eskip	ast.h	/^  Eskip,        \/* skip                                 *\/$/;"	e	enum:ExpnType_tag
EtypeMismatch	semantics.c	/^    EtypeMismatch,          \/* type mistmatch in expression     *\/$/;"	e	file:
Eunary	ast.h	/^  Eunary ,      \/* unary operator                       *\/$/;"	e	enum:ExpnType_tag
EundeclaredFunc	semantics.c	/^    EundeclaredFunc,        \/* undeclared function reference    *\/$/;"	e	file:
EundeclaredProc	semantics.c	/^    EundeclaredProc,        \/* undeclared procedure reference   *\/$/;"	e	file:
EundeclaredVariable	semantics.c	/^    EundeclaredVariable,    \/* undeclared variable referenced   *\/$/;"	e	file:
Eunknown	semantics.c	/^    Eunknown                \/* non-implemented error            *\/$/;"	e	file:
Evar	ast.h	/^  Evar ,        \/* variable                             *\/$/;"	e	enum:ExpnType_tag
ExpnObj	astDef.h	/^} ExpnObj;$/;"	t
ExpnP	astDef.h	/^typedef struct Expn_tag   * ExpnP ;     \/* Expressions  *\/$/;"	t
ExpnType	ast.h	/^} ExpnType;$/;"	t
ExpnType_tag	ast.h	/^typedef enum ExpnType_tag {$/;"	g
Expn_tag	astDef.h	/^typedef struct Expn_tag {$/;"	s
FALSE	common.h	33;"	d
FI	parser.tab.c	13;"	d	file:
FI	parser.tab.h	28;"	d
FLEX	Makefile	/^FLEX = flex$/;"	m
FLEXFLAGS	Makefile	/^FLEXFLAGS = -oscanner.c -Cae -I$/;"	m
FLEX_SCANNER	scanner.c	8;"	d	file:
FParm_tag	astDef.h	/^typedef struct FParm_tag {$/;"	s
FParms	astDef.h	/^} FParms ;$/;"	t
Flags	codegen.c	/^} Flags;$/;"	v
FlagsP	codegen.c	/^typedef struct Flags_tag * FlagsP;$/;"	t	file:
Flags_tag	codegen.c	/^struct Flags_tag {$/;"	s	file:
FparmP	astDef.h	/^typedef struct FParm_tag  * FparmP ;    \/* Formal Parm  *\/$/;"	t
GET	parser.tab.c	14;"	d	file:
GET	parser.tab.h	29;"	d
HALT	machineDef.h	/^	HALT = 0, ADDR,  LOAD, STORE, PUSH, PUSHMT, SETD, POP,    $/;"	e	enum:InstructionCodes
HAST	Makefile	/^HAST	    = astDef.h  $/;"	m
HCOMMON	Makefile	/^HCOMMON     = common.h globalvars.h$/;"	m
HFILES	Makefile	/^HFILES  =  $(HINTERFACES) $(HTABLES) $(HCOMMON) $(HMACHINE) $(HAST)$/;"	m
HINTERFACES	Makefile	/^HINTERFACES = ast.h semantics.h symbol.h machine.h $/;"	m
HMACHINE	Makefile	/^HMACHINE    = machineDef.h$/;"	m
IDENT	parser.tab.c	6;"	d	file:
IDENT	parser.tab.h	21;"	d
IF	parser.tab.c	15;"	d	file:
IF	parser.tab.h	30;"	d
INDENT_MAX	astDump.c	59;"	d	file:
INDENT_STEP	astDump.c	57;"	d	file:
INITIAL	scanner.c	417;"	d	file:
INT	parser.tab.c	16;"	d	file:
INT	parser.tab.h	31;"	d
INTCONST	parser.tab.c	8;"	d	file:
INTCONST	parser.tab.h	23;"	d
InstructionCodes	machineDef.h	/^enum InstructionCodes {$/;"	g
LINKFILES	Makefile	/^LINKFILES = $/;"	m
LINKFLAGS	Makefile	/^LINKFLAGS = -lfl$/;"	m
LOAD	machineDef.h	/^	HALT = 0, ADDR,  LOAD, STORE, PUSH, PUSHMT, SETD, POP,    $/;"	e	enum:InstructionCodes
LOG	ast.c	/^void LOG( char * msg )$/;"	f
LOG	astTest.c	/^void LOG(char * msg)$/;"	f
LT	machineDef.h	/^	MUL,	  DIV,   EQ,   LT,    OR,   SWAP,   READC,PRINTC, $/;"	e	enum:InstructionCodes
LitObj	astDef.h	/^} LitObj;$/;"	t
LitObjP	astDef.h	/^typedef struct LitObj_tag * LitObjP;    \/* Literal      *\/$/;"	t
LitObj_tag	astDef.h	/^typedef struct LitObj_tag {$/;"	s
MACHINE_CONSTS	machineDef.h	81;"	d
MACHINE_CONSTS	machineDef.h	84;"	d
MACHINE_FALSE	machineDef.h	135;"	d
MACHINE_TRUE	machineDef.h	134;"	d
MAKE	Makefile	/^MAKE  = make$/;"	m
MAKEDEP	Makefile	/^MAKEDEP = makedepend	$/;"	m
MAX_ARR	semantics.h	22;"	d
MAX_IDENTIFIER	common.h	47;"	d
MAX_INTEGER	common.h	56;"	d
MAX_TEXT	common.h	63;"	d
MEMORYSIZE	machineDef.h	32;"	d
MEMORYWORD	machineDef.h	/^typedef  short	MEMORYWORD ;$/;"	t
MEMORY_TOP	machine.c	255;"	d	file:
MIN_ARR	semantics.h	21;"	d
MIN_INTEGER	machineDef.h	48;"	d
MUL	machineDef.h	/^	MUL,	  DIV,   EQ,   LT,    OR,   SWAP,   READC,PRINTC, $/;"	e	enum:InstructionCodes
NEG	machineDef.h	/^	POPN,     DUP,   DUPN, BR,    BF,   NEG,    ADD,  SUB,$/;"	e	enum:InstructionCodes
NFLAGS	Makefile	/^NFLAGS	= -man$/;"	m
NL	scanner.c	463;"	d	file:
NROFF	Makefile	/^NROFF	= nroff$/;"	m
OD	parser.tab.c	17;"	d	file:
OD	parser.tab.h	32;"	d
OFILES	Makefile	/^OFILES = main.o scanner.o parser.o semantics.o codegen.o symbol.o machine.o ast.o astDump.o$/;"	m
OPERNAME	astDump.c	96;"	d	file:
OR	machineDef.h	/^	MUL,	  DIV,   EQ,   LT,    OR,   SWAP,   READC,PRINTC, $/;"	e	enum:InstructionCodes
Oadd	ast.h	/^  Oadd,         \/* Addition                             *\/$/;"	e	enum:OperType_tag
Oand	ast.h	/^  Oand ,        \/* Boolean and                          *\/$/;"	e	enum:OperType_tag
ObjType	ast.h	/^} ObjType;$/;"	t
ObjType_tag	ast.h	/^typedef enum ObjType_tag {$/;"	g
Object	astDef.h	/^} Object ;$/;"	t
ObjectP	astDef.h	/^typedef struct Object_tag * ObjectP;    \/* Objects      *\/$/;"	t
Object_tag	astDef.h	/^typedef struct Object_tag {$/;"	s
Odecl	ast.h	/^  Odecl ,       \/* declaration                          *\/$/;"	e	enum:ObjType_tag
Odiv	ast.h	/^  Odiv,         \/* Divide                               *\/$/;"	e	enum:OperType_tag
Oeq	ast.h	/^  Oeq ,         \/* Equality                             *\/$/;"	e	enum:OperType_tag
Oexpn	ast.h	/^  Oexpn ,       \/* expression                           *\/$/;"	e	enum:ObjType_tag
Ogrtr	ast.h	/^  Ogrtr ,       \/* Greater                              *\/$/;"	e	enum:OperType_tag
Ogrtreq	ast.h	/^  Ogrtreq ,     \/* Greater or equal                     *\/$/;"	e	enum:OperType_tag
Oless	ast.h	/^  Oless ,       \/* Less                                 *\/$/;"	e	enum:OperType_tag
Olesseq	ast.h	/^  Olesseq ,     \/* Less or equal                        *\/$/;"	e	enum:OperType_tag
Omul	ast.h	/^  Omul,         \/* Multiplication                       *\/$/;"	e	enum:OperType_tag
Oneq	ast.h	/^  Oneq ,        \/* Inequality                           *\/$/;"	e	enum:OperType_tag
Onone	ast.h	/^  Onone ,       \/* None, unknown                        *\/$/;"	e	enum:ObjType_tag
Onop	ast.h	/^  Onop ,        \/* None, unknown                        *\/$/;"	e	enum:OperType_tag
Onot	ast.h	/^  Onot ,        \/* Boolean not                          *\/$/;"	e	enum:OperType_tag
Oor	ast.h	/^  Oor ,         \/* Boolean or                           *\/$/;"	e	enum:OperType_tag
OperType	ast.h	/^} OperType;$/;"	t
OperType_tag	ast.h	/^typedef enum OperType_tag {$/;"	g
Oscope	ast.h	/^  Oscope ,      \/* scope                                *\/$/;"	e	enum:ObjType_tag
Ostmt	ast.h	/^  Ostmt         \/* statement                            *\/$/;"	e	enum:ObjType_tag
Osub	ast.h	/^  Osub,         \/* Subtraction                          *\/$/;"	e	enum:OperType_tag
Osubs	ast.h	/^  Osubs         \/* subscript                            *\/$/;"	e	enum:OperType_tag
Ouminus	ast.h	/^  Ouminus ,     \/* Unary minus                          *\/$/;"	e	enum:OperType_tag
POP	machineDef.h	/^	HALT = 0, ADDR,  LOAD, STORE, PUSH, PUSHMT, SETD, POP,    $/;"	e	enum:InstructionCodes
POPN	machineDef.h	/^	POPN,     DUP,   DUPN, BR,    BF,   NEG,    ADD,  SUB,$/;"	e	enum:InstructionCodes
PRINTC	machineDef.h	/^	MUL,	  DIV,   EQ,   LT,    OR,   SWAP,   READC,PRINTC, $/;"	e	enum:InstructionCodes
PRINTI	machineDef.h	/^	READI,    PRINTI,TRON, TROFF $/;"	e	enum:InstructionCodes
PROC	parser.tab.c	18;"	d	file:
PROC	parser.tab.h	33;"	d
PSFLAGS	Makefile	/^PSFLAGS = -man -t$/;"	m
PSROFF	Makefile	/^PSROFF	= psroff$/;"	m
PUSH	machineDef.h	/^	HALT = 0, ADDR,  LOAD, STORE, PUSH, PUSHMT, SETD, POP,    $/;"	e	enum:InstructionCodes
PUSHMT	machineDef.h	/^	HALT = 0, ADDR,  LOAD, STORE, PUSH, PUSHMT, SETD, POP,    $/;"	e	enum:InstructionCodes
PUT	parser.tab.c	19;"	d	file:
PUT	parser.tab.h	34;"	d
READC	machineDef.h	/^	MUL,	  DIV,   EQ,   LT,    OR,   SWAP,   READC,PRINTC, $/;"	e	enum:InstructionCodes
READI	machineDef.h	/^	READI,    PRINTI,TRON, TROFF $/;"	e	enum:InstructionCodes
REJECT	scanner.c	411;"	d	file:
RESULT	parser.tab.c	21;"	d	file:
RESULT	parser.tab.h	36;"	d
RETURN	parser.tab.c	22;"	d	file:
RETURN	parser.tab.h	37;"	d
SETD	machineDef.h	/^	HALT = 0, ADDR,  LOAD, STORE, PUSH, PUSHMT, SETD, POP,    $/;"	e	enum:InstructionCodes
SETINDENT	astDump.c	65;"	d	file:
SKIP	parser.tab.c	20;"	d	file:
SKIP	parser.tab.h	35;"	d
SLOG	semantics.c	/^void SLOG( char * msg )$/;"	f
SPOP	machine.c	268;"	d	file:
SPUSH	machine.c	267;"	d	file:
STMTNAME	astDump.c	88;"	d	file:
STORE	machineDef.h	/^	HALT = 0, ADDR,  LOAD, STORE, PUSH, PUSHMT, SETD, POP,    $/;"	e	enum:InstructionCodes
SUB	machineDef.h	/^	POPN,     DUP,   DUPN, BR,    BF,   NEG,    ADD,  SUB,$/;"	e	enum:InstructionCodes
SWAP	machineDef.h	/^	MUL,	  DIV,   EQ,   LT,    OR,   SWAP,   READC,PRINTC, $/;"	e	enum:InstructionCodes
Sassign	ast.h	/^  Sassign ,     \/* assignment                           *\/$/;"	e	enum:StmtType_tag
Scall	ast.h	/^  Scall ,       \/* procedure call                       *\/$/;"	e	enum:StmtType_tag
ScopeObj	astDef.h	/^} ScopeObj ;$/;"	t
ScopeP	astDef.h	/^typedef struct Scope_tag  * ScopeP ;    \/* Scopes       *\/$/;"	t
Scope_tag	astDef.h	/^typedef struct Scope_tag {$/;"	s
Sdo	ast.h	/^  Sdo,          \/* do until                             *\/$/;"	e	enum:StmtType_tag
Sexit	ast.h	/^  Sexit ,       \/* exit                                 *\/$/;"	e	enum:StmtType_tag
Sget	ast.h	/^  Sget ,        \/* get                                  *\/$/;"	e	enum:StmtType_tag
Sif	ast.h	/^  Sif ,         \/* if without else                      *\/$/;"	e	enum:StmtType_tag
Sifelse	ast.h	/^  Sifelse ,     \/* if with else                         *\/$/;"	e	enum:StmtType_tag
Snone	ast.h	/^  Snone ,       \/* none, unknown                        *\/$/;"	e	enum:StmtType_tag
Sput	ast.h	/^  Sput ,        \/* put                                  *\/$/;"	e	enum:StmtType_tag
Sresult	ast.h	/^  Sresult ,     \/* result                               *\/$/;"	e	enum:StmtType_tag
Sreturn	ast.h	/^  Sreturn ,     \/* return                               *\/$/;"	e	enum:StmtType_tag
Sscope	ast.h	/^  Sscope        \/* scope                                *\/$/;"	e	enum:StmtType_tag
StmtObj	astDef.h	/^} StmtObj ;$/;"	t
StmtP	astDef.h	/^typedef struct Stmt_tag   * StmtP ;     \/* Statements   *\/$/;"	t
StmtType	ast.h	/^} StmtType;$/;"	t
StmtType_tag	ast.h	/^typedef enum StmtType_tag {$/;"	g
Stmt_tag	astDef.h	/^typedef struct Stmt_tag {$/;"	s
Swhile	ast.h	/^  Swhile ,      \/* while                                *\/$/;"	e	enum:StmtType_tag
SymbTabEntry	symbol.c	/^} SymbTabEntry;$/;"	t	file:
SymbTabEntryInfo	symbol.h	/^} SymbTabEntryInfo;$/;"	t
SymbTabEntryInfoP	symbol.h	/^typedef struct SymbTabEntryInfo_tag *SymbTabEntryInfoP;$/;"	t
SymbTabEntryInfo_tag	symbol.h	/^typedef struct SymbTabEntryInfo_tag {$/;"	s
SymbTabEntryP	symbol.c	/^typedef struct SymbTabEntry_tag *SymbTabEntryP;$/;"	t	file:
SymbTabEntry_tag	symbol.c	/^typedef struct SymbTabEntry_tag {$/;"	s	file:
SymbTable	symbol.c	/^static SymbTabEntryP SymbTable;$/;"	v	file:
SymbTableSize	symbol.h	11;"	d
TARGET	Makefile	/^TARGET	=  compiler488$/;"	m
TEXTCONST	parser.tab.c	7;"	d	file:
TEXTCONST	parser.tab.h	22;"	d
TFALSE	parser.tab.c	24;"	d	file:
TFALSE	parser.tab.h	39;"	d
THEN	parser.tab.c	23;"	d	file:
THEN	parser.tab.h	38;"	d
TOP	machine.c	269;"	d	file:
TOPM1	machine.c	271;"	d	file:
TOPP1	machine.c	270;"	d	file:
TROFF	machineDef.h	/^	READI,    PRINTI,TRON, TROFF $/;"	e	enum:InstructionCodes
TRON	machineDef.h	/^	READI,    PRINTI,TRON, TROFF $/;"	e	enum:InstructionCodes
TRUE	common.h	29;"	d
TS_CHAR	scanner.c	450;"	d	file:
TS_TEXT	scanner.c	449;"	d	file:
TTRUE	parser.tab.c	25;"	d	file:
TTRUE	parser.tab.h	40;"	d
TT_TOKEN	scanner.c	451;"	d	file:
TYPENAME	astDump.c	80;"	d	file:
UNDEFINED	machineDef.h	55;"	d
UNTIL	parser.tab.c	26;"	d	file:
UNTIL	parser.tab.h	41;"	d
VERBOSITY	astTest.c	12;"	d	file:
WHILE	parser.tab.c	27;"	d	file:
WHILE	parser.tab.h	42;"	d
YYABORT	parser.tab.c	510;"	d	file:
YYACCEPT	parser.tab.c	509;"	d	file:
YYBACKUP	parser.tab.c	517;"	d	file:
YYBISON	parser.tab.c	4;"	d	file:
YYCOPY	parser.tab.c	456;"	d	file:
YYCOPY	parser.tab.c	459;"	d	file:
YYDEBUG	parser.tab.c	82;"	d	file:
YYDPRINTF	parser.tab.c	581;"	d	file:
YYDPRINTF	parser.tab.c	590;"	d	file:
YYEMPTY	parser.tab.c	507;"	d	file:
YYEOF	parser.tab.c	508;"	d	file:
YYERRCODE	parser.tab.c	535;"	d	file:
YYERROR	parser.tab.c	511;"	d	file:
YYFAIL	parser.tab.c	515;"	d	file:
YYFINAL	parser.tab.c	87;"	d	file:
YYFLAG	parser.tab.c	88;"	d	file:
YYFPRINTF	parser.tab.c	578;"	d	file:
YYINITDEPTH	parser.tab.c	595;"	d	file:
YYLAST	parser.tab.c	287;"	d	file:
YYLEX	parser.tab.c	557;"	d	file:
YYLEX	parser.tab.c	559;"	d	file:
YYLEX	parser.tab.c	563;"	d	file:
YYLEX	parser.tab.c	565;"	d	file:
YYLEX	parser.tab.c	569;"	d	file:
YYLLOC_DEFAULT	parser.tab.c	546;"	d	file:
YYMAXDEPTH	parser.tab.c	606;"	d	file:
YYMAXDEPTH	parser.tab.c	610;"	d	file:
YYNTBASE	parser.tab.c	89;"	d	file:
YYPARSE_PARAM_ARG	parser.tab.c	676;"	d	file:
YYPARSE_PARAM_ARG	parser.tab.c	679;"	d	file:
YYPARSE_PARAM_ARG	parser.tab.c	683;"	d	file:
YYPARSE_PARAM_DECL	parser.tab.c	677;"	d	file:
YYPARSE_PARAM_DECL	parser.tab.c	680;"	d	file:
YYPARSE_PARAM_DECL	parser.tab.c	684;"	d	file:
YYPOPSTACK	parser.tab.c	770;"	d	file:
YYPOPSTACK	parser.tab.c	772;"	d	file:
YYRECOVERING	parser.tab.c	516;"	d	file:
YYSIZE_T	parser.tab.c	415;"	d	file:
YYSIZE_T	parser.tab.c	490;"	d	file:
YYSIZE_T	parser.tab.c	493;"	d	file:
YYSIZE_T	parser.tab.c	498;"	d	file:
YYSIZE_T	parser.tab.c	502;"	d	file:
YYSTACK_ALLOC	parser.tab.c	396;"	d	file:
YYSTACK_ALLOC	parser.tab.c	400;"	d	file:
YYSTACK_ALLOC	parser.tab.c	403;"	d	file:
YYSTACK_ALLOC	parser.tab.c	417;"	d	file:
YYSTACK_BYTES	parser.tab.c	443;"	d	file:
YYSTACK_BYTES	parser.tab.c	447;"	d	file:
YYSTACK_FREE	parser.tab.c	411;"	d	file:
YYSTACK_FREE	parser.tab.c	418;"	d	file:
YYSTACK_GAP_MAX	parser.tab.c	438;"	d	file:
YYSTACK_RELOCATE	parser.tab.c	475;"	d	file:
YYSTACK_RELOCATE	parser.tab.c	876;"	d	file:
YYSTATE	scanner.c	87;"	d	file:
YYSTYPE	parser.tab.c	78;"	d	file:
YYSTYPE	parser.tab.h	18;"	d
YYSTYPE_IS_TRIVIAL	parser.tab.c	79;"	d	file:
YYSTYPE_IS_TRIVIAL	parser.tab.h	19;"	d
YYTERROR	parser.tab.c	534;"	d	file:
YYTRANSLATE	parser.tab.c	92;"	d	file:
YY_AT_BOL	scanner.c	263;"	d	file:
YY_BREAK	scanner.c	611;"	d	file:
YY_BUFFER_EOF_PENDING	scanner.c	199;"	d	file:
YY_BUFFER_NEW	scanner.c	187;"	d	file:
YY_BUFFER_NORMAL	scanner.c	188;"	d	file:
YY_BUFFER_STATE	scanner.c	/^typedef struct yy_buffer_state *YY_BUFFER_STATE;$/;"	t	file:
YY_BUF_SIZE	scanner.c	98;"	d	file:
YY_CHAR	scanner.c	/^typedef unsigned char YY_CHAR;$/;"	t	file:
YY_CURRENT_BUFFER	scanner.c	208;"	d	file:
YY_DECL	scanner.c	599;"	d	file:
YY_DECL_NON_LSP_VARIABLES	parser.tab.c	699;"	d	file:
YY_DECL_VARIABLES	parser.tab.c	710;"	d	file:
YY_DECL_VARIABLES	parser.tab.c	716;"	d	file:
YY_DO_BEFORE_ACTION	scanner.c	279;"	d	file:
YY_END_OF_BUFFER	scanner.c	287;"	d	file:
YY_END_OF_BUFFER_CHAR	scanner.c	95;"	d	file:
YY_EXIT_FAILURE	scanner.c	1760;"	d	file:
YY_FATAL_ERROR	scanner.c	592;"	d	file:
YY_FLEX_MAJOR_VERSION	scanner.c	9;"	d	file:
YY_FLEX_MINOR_VERSION	scanner.c	10;"	d	file:
YY_FLUSH_BUFFER	scanner.c	237;"	d	file:
YY_INPUT	scanner.c	559;"	d	file:
YY_MORE_ADJ	scanner.c	413;"	d	file:
YY_NEW_FILE	scanner.c	93;"	d	file:
YY_NO_POP_STATE	scanner.c	522;"	d	file:
YY_NO_PUSH_STATE	scanner.c	521;"	d	file:
YY_NO_TOP_STATE	scanner.c	523;"	d	file:
YY_NULL	scanner.c	67;"	d	file:
YY_NUM_RULES	scanner.c	286;"	d	file:
YY_PROTO	scanner.c	61;"	d	file:
YY_PROTO	scanner.c	63;"	d	file:
YY_READ_BUF_SIZE	scanner.c	543;"	d	file:
YY_RESTORE_YY_MORE_OFFSET	scanner.c	414;"	d	file:
YY_RULE_SETUP	scanner.c	614;"	d	file:
YY_SC_TO_UI	scanner.c	74;"	d	file:
YY_START	scanner.c	86;"	d	file:
YY_START_STACK_INCR	scanner.c	587;"	d	file:
YY_STATE_EOF	scanner.c	90;"	d	file:
YY_USER_ACTION	scanner.c	606;"	d	file:
YY_USE_CONST	scanner.c	32;"	d	file:
YY_USE_CONST	scanner.c	39;"	d	file:
YY_USE_CONST	scanner.c	49;"	d	file:
YY_USE_PROTOS	scanner.c	29;"	d	file:
YY_USE_PROTOS	scanner.c	38;"	d	file:
YY_USE_PROTOS	scanner.c	50;"	d	file:
_ASTDEF_H_	astDef.h	2;"	d
_AST_H_	ast.h	2;"	d
_COMMON_H_	common.h	8;"	d
_GLOBAL_VARS_H_	globalvars.h	2;"	d
_MACHINE_DEF_H_	machineDef.h	9;"	d
_MACHINE_H_	machine.h	8;"	d
_SEMANTICS_H_	semantics.h	2;"	d
_SYMBOL_H	symbol.h	8;"	d
__cplusplus	scanner.c	19;"	d	file:
_codegen_H_	codegen.h	2;"	d
anext	astDef.h	/^  ArgsP    anext;        \/* next argument               *\/$/;"	m	struct:Args_tag
argsP	parser.tab.c	/^        ArgsP argsP;$/;"	m	union:	file:
argsP	parser.tab.h	/^        ArgsP argsP;$/;"	m	union:
arguments	parser.y	/^arguments       :  expression $/;"	l
arithExpr	parser.y	/^arithExpr       :  term$/;"	l
astDef_RCSId	astDef.h	/^static const char * astDef_RCSId = "$RCSfile: astDef.h,v $ $Revision: 1.2 $ $Date: 2003\/02\/27 15:55:40 $" ;$/;"	v
astDump	astDump.c	/^void astDump( const ASTtype  dumpTree)$/;"	f
astDump_c_RCSId	astDump.c	/^static const char * astDump_c_RCSId = "$RCSfile: astDump.c,v $ $Revision: 1.1 $ $Date: 2003\/02\/27 14:09:56 $" ;$/;"	v	file:
astFinalize	ast.c	/^void astFinalize(ASTtype *  deadTree ) {$/;"	f
astInitialize	ast.c	/^void astInitialize(ASTtype *  newTree ) {$/;"	f
ast_c_RCSId	ast.c	/^static const char * ast_c_RCSId = "$RCSfile: ast.c,v $ $Revision: 1.7 $ $Date: 2003\/03\/30 17:29:37 $" ;$/;"	v	file:
ast_h_RCSId	ast.h	/^static const char * ast_h_RCSId = "$RCSfile: ast.h,v $ $Revision: 1.2 $ $Date: 2003\/02\/27 17:06:12 $" ;$/;"	v
avalue	astDef.h	/^  ExpnP   avalue;       \/* argument expression          *\/$/;"	m	struct:Args_tag
checkDecl	semantics.c	/^void checkDecl( DeclP decl ) {$/;"	f
checkExpn	semantics.c	/^DataType checkExpn( ExpnP expn ) {$/;"	f
checkFParam	semantics.c	/^void checkFParam ( FparmP params ) {$/;"	f
checkGetArgs	semantics.c	/^void checkGetArgs( ArgsP args ){$/;"	f
checkLiteral	semantics.c	/^DataType checkLiteral( LitObj lit ){$/;"	f
checkPutArgs	semantics.c	/^void checkPutArgs( ArgsP args ){$/;"	f
checkScope	semantics.c	/^void checkScope( ScopeP scope, commFlagsP flags ){$/;"	f
checkStmt	semantics.c	/^void checkStmt( StmtP stmt, commFlagsP flags ) $/;"	f
checkStmt_list	semantics.c	/^void checkStmt_list( ObjectP stmts, commFlagsP flags ) $/;"	f
codegenBegin	codegen.c	/^void codegenBegin( ASTtype tree ) $/;"	f
codegenCopyFlags	codegen.c	/^FlagsP codegenCopyFlags( FlagsP flags )$/;"	f
codegenDecl	codegen.c	/^void codegenDecl( DeclP decl )$/;"	f
codegenDeclArray	codegen.c	/^void codegenDeclArray( DeclP decl )$/;"	f
codegenDeclRoutine	codegen.c	/^void codegenDeclRoutine( DeclP decl, BOOLEAN isFunction )$/;"	f
codegenDeclScalar	codegen.c	/^void codegenDeclScalar( )$/;"	f
codegenFinalize	codegen.c	/^void codegenFinalize( ) {$/;"	f
codegenInitFlags	codegen.c	/^FlagsP codegenInitFlags( )$/;"	f
codegenInitialize	codegen.c	/^void codegenInitialize( ){$/;"	f
codegenMajorScopeCleanup	codegen.c	/^void codegenMajorScopeCleanup( int lexiclevel )$/;"	f
codegenMajorScopeSetup	codegen.c	/^void codegenMajorScopeSetup( ScopeP scope )$/;"	f
codegenPushExpn	codegen.c	/^void codegenPushExpn( ExpnP expn )$/;"	f
codegenPushExpnBinary	codegen.c	/^void codegenPushExpnBinary( ExpnP expn )$/;"	f
codegenPushExpnBinaryAnd	codegen.c	/^void codegenPushExpnBinaryAnd( ExpnP expn )$/;"	f
codegenPushExpnBinaryBuiltIn	codegen.c	/^void codegenPushExpnBinaryBuiltIn( ExpnP expn, int operator )$/;"	f
codegenPushExpnBinaryComparison	codegen.c	/^void codegenPushExpnBinaryComparison( ExpnP lop, ExpnP rop, int threshold )$/;"	f
codegenPushExpnBinaryNEq	codegen.c	/^void codegenPushExpnBinaryNEq( ExpnP expn ) $/;"	f
codegenPushExpnBinaryOr	codegen.c	/^void codegenPushExpnBinaryOr( ExpnP expn )$/;"	f
codegenPushExpnBinarySubs	codegen.c	/^void codegenPushExpnBinarySubs( ExpnP expn )$/;"	f
codegenPushExpnCond	codegen.c	/^void codegenPushExpnCond( ExpnP expn )$/;"	f
codegenPushExpnConst	codegen.c	/^void codegenPushExpnConst( ExpnP expn )$/;"	f
codegenPushExpnUnary	codegen.c	/^void codegenPushExpnUnary( ExpnP expn )$/;"	f
codegenPushExpnVar	codegen.c	/^void codegenPushExpnVar( ExpnP expn )$/;"	f
codegenRoutineCall	codegen.c	/^void codegenRoutineCall( char *name, ArgsP args, BOOLEAN isFunction )$/;"	f
codegenRoutineCleanup	codegen.c	/^void codegenRoutineCleanup( ScopeP scope, int lexiclevel, int argcount )$/;"	f
codegenRoutineSetup	codegen.c	/^void codegenRoutineSetup( ScopeP scope, int lexiclevel, int argcount )$/;"	f
codegenScope	codegen.c	/^void codegenScope( ScopeP scope, FlagsP flags )$/;"	f
codegenStmt	codegen.c	/^void codegenStmt( StmtP stmt, FlagsP flags ) $/;"	f
codegenStmtAssign	codegen.c	/^void codegenStmtAssign( StmtP stmt )$/;"	f
codegenStmtDo	codegen.c	/^void codegenStmtDo( StmtP stmt, FlagsP flags )$/;"	f
codegenStmtExit	codegen.c	/^void codegenStmtExit( StmtP stmt, FlagsP flags )$/;"	f
codegenStmtGet	codegen.c	/^void codegenStmtGet( StmtP stmt )$/;"	f
codegenStmtIf	codegen.c	/^void codegenStmtIf( StmtP stmt, FlagsP flags ) $/;"	f
codegenStmtIfElse	codegen.c	/^void codegenStmtIfElse( StmtP stmt, FlagsP flags)$/;"	f
codegenStmtList	codegen.c	/^void codegenStmtList( ObjectP stmts, FlagsP flags ) $/;"	f
codegenStmtMajorScope	codegen.c	/^void codegenStmtMajorScope( StmtP stmt, FlagsP flags )$/;"	f
codegenStmtPut	codegen.c	/^void codegenStmtPut( StmtP stmt )$/;"	f
codegenStmtResult	codegen.c	/^void codegenStmtResult( StmtP stmt, FlagsP flags )$/;"	f
codegenStmtReturn	codegen.c	/^void codegenStmtReturn( StmtP stmt, FlagsP flags )$/;"	f
codegenStmtWhile	codegen.c	/^void codegenStmtWhile( StmtP stmt, FlagsP flags)$/;"	f
codegen_c_RCSId	codegen.c	/^static const char * codegen_c_RCSId = "$RCSfile: codegen.c,v $ $Revision: 1.65 $ $Date: 2003\/04\/01 00:23:32 $" ;$/;"	v	file:
codegen_h_RCSId	codegen.h	/^static const char * codegen_h_RCSId = "$RCSfile: codegen.h,v $ $Revision: 1.8 $ $Date: 2003\/03\/27 01:19:14 $" ;$/;"	v
commFlags	semantics.c	/^} commFlags;$/;"	t	file:
commFlagsP	semantics.c	/^typedef struct commFlags_Tag *commFlagsP;$/;"	t	file:
commFlags_Tag	semantics.c	/^typedef struct commFlags_Tag {$/;"	s	file:
common_h_RCSId	common.h	/^static const char * common_h_RCSId = "$RCSfile: common.h,v $ $Revision: 1.1 $ $Date: 2003\/02\/27 14:09:56 $" ;$/;"	v
compareExpr	parser.y	/^compareExpr     :  arithExpr$/;"	l
confalse	astDef.h	/^        ExpnP  confalse ;    \/* false expression        *\/$/;"	m	struct:Expn_tag::expnVal_tag::expnCd_tag
conjunction	parser.y	/^conjunction     :  negation$/;"	l
constant	parser.y	/^constant        :  INTCONST$/;"	l
control	astDef.h	/^        ExpnP  control ;     \/* control expression      *\/$/;"	m	struct:Expn_tag::expnVal_tag::expnCd_tag
contrue	astDef.h	/^        ExpnP  contrue ;     \/* true expression         *\/$/;"	m	struct:Expn_tag::expnVal_tag::expnCd_tag
convertEntry	symbol.c	/^void convertEntry(SymbTabEntryP src, SymbTabEntryInfoP dest)$/;"	f
dbound	astDef.h	/^  int       dbound;      \/* array bound (if any)        *\/$/;"	m	struct:Decl_tag
dbound	symbol.c	/^    int dbound;$/;"	m	struct:SymbTabEntry_tag	file:
dbound	symbol.h	/^   int dbound;$/;"	m	struct:SymbTabEntryInfo_tag
dctype	astDef.h	/^  DclType   dctype ;     \/* type of declaration         *\/$/;"	m	struct:Decl_tag
dctype	symbol.c	/^    DclType  dctype;$/;"	m	struct:SymbTabEntry_tag	file:
dctype	symbol.h	/^   DclType  dctype;$/;"	m	struct:SymbTabEntryInfo_tag
decl	astDef.h	/^        DeclP  decl ;           \/* declaration          *\/$/;"	m	union:Object_tag::objectValue_tag
declNames	astDump.c	/^char * declNames[] = { "unknown", "scalar",  "array", "function", $/;"	v
declP	parser.tab.c	/^        DeclP declP;$/;"	m	union:	file:
declP	parser.tab.h	/^        DeclP declP;$/;"	m	union:
declaration	parser.y	/^declaration     :  typeAndIdent $/;"	l
declarations	parser.y	/^declarations    :  declaration $/;"	l
dfparm	astDef.h	/^  FparmP    dfparm;      \/* formal parameters (if any)  *\/$/;"	m	struct:Decl_tag
dfparm	symbol.c	/^    FparmP dfparm;$/;"	m	struct:SymbTabEntry_tag	file:
dfparm	symbol.h	/^   FparmP dfparm;$/;"	m	struct:SymbTabEntryInfo_tag
display	machine.c	/^int display[ DISPLAYSIZE ] ;$/;"	v
displayMax	machine.c	/^int displayMax = -1 ;$/;"	v
dname	astDef.h	/^  char *    dname;       \/* variable\/func name          *\/$/;"	m	struct:Decl_tag
dobject	astDef.h	/^  ObjectP   dobject;     \/* associated object (if any)  *\/$/;"	m	struct:Decl_tag
dscope	astDef.h	/^  ScopeP    dscope ;     \/* containing scope (if any)   *\/$/;"	m	struct:Decl_tag
dtype	astDef.h	/^  DataType  dtype;       \/* data type                   *\/$/;"	m	struct:Decl_tag
dtype	symbol.c	/^    DataType dtype;$/;"	m	struct:SymbTabEntry_tag	file:
dtype	symbol.h	/^   DataType dtype;$/;"	m	struct:SymbTabEntryInfo_tag
dumpAST1	globalvars.h	/^EXTERN_GLOBALS  BOOLEAN  dumpAST1 ;$/;"	v
dumpAST2	globalvars.h	/^EXTERN_GLOBALS  BOOLEAN  dumpAST2 ;$/;"	v
dumpFile	globalvars.h	/^EXTERN_GLOBALS FILE *  dumpFile ;$/;"	v
dumpInstructions	globalvars.h	/^EXTERN_GLOBALS BOOLEAN  dumpInstructions ;$/;"	v
dumpMachineState	machine.c	/^static void dumpMachineState( FILE * sinkFile, char * msg,$/;"	f	file:
dumpSymbols	globalvars.h	/^EXTERN_GLOBALS  BOOLEAN  dumpSymbols ;$/;"	v
econx	astDef.h	/^    } econx ;$/;"	m	union:Expn_tag::expnVal_tag
efargs	astDef.h	/^         ArgsP   efargs ;    \/* list of arguments (if any) *\/$/;"	m	struct:Expn_tag::expnVal_tag::expnFn_tag
efn	astDef.h	/^    } efn ;$/;"	m	union:Expn_tag::expnVal_tag
efname	astDef.h	/^         char *  efname ;    \/* name of function        *\/$/;"	m	struct:Expn_tag::expnVal_tag::expnFn_tag
eident	astDef.h	/^    char *      eident ;     \/*  identifier             *\/$/;"	m	union:Expn_tag::expnVal_tag
elitVal	astDef.h	/^    LitObj      elitVal ;    \/* literal constant        *\/$/;"	m	union:Expn_tag::expnVal_tag
eop	astDef.h	/^    } eop ;$/;"	m	union:Expn_tag::expnVal_tag
eoper	astDef.h	/^        OperType eoper ;     \/* type of operator        *\/$/;"	m	struct:Expn_tag::expnVal_tag::expnOp_tag
eopleft	astDef.h	/^        ExpnP    eopleft ;   \/* left operand (if any )  *\/$/;"	m	struct:Expn_tag::expnVal_tag::expnOp_tag
eopright	astDef.h	/^        ExpnP    eopright ;  \/* right operand (if any)  *\/$/;"	m	struct:Expn_tag::expnVal_tag::expnOp_tag
errorFile	globalvars.h	/^EXTERN_GLOBALS FILE *  errorFile ;$/;"	v
errorOccurred	globalvars.h	/^EXTERN_GLOBALS BOOLEAN errorOccurred ;$/;"	v
error_msg	semantics.c	/^void error_msg( errors err_code, int line, char * ext_msg ){$/;"	f
errors	semantics.c	/^} errors;$/;"	t	file:
etype	astDef.h	/^  ExpnType  etype;      \/* type of expression           *\/$/;"	m	struct:Expn_tag
evalue	astDef.h	/^  } evalue;     \/* value of the expression              *\/$/;"	m	struct:Expn_tag
executing	machine.c	/^BOOLEAN  executing = TRUE ;$/;"	v
exitBackpatchHead	codegen.c	/^    int exitBackpatchHead;    \/* address to head of list        *\/$/;"	m	struct:Flags_tag	file:
expn	astDef.h	/^        ExpnP  expn ;           \/* expression           *\/$/;"	m	union:Object_tag::objectValue_tag
expnCd_tag	astDef.h	/^    struct expnCd_tag {      \/* conditional expression  *\/$/;"	s	union:Expn_tag::expnVal_tag
expnFn_tag	astDef.h	/^    struct expnFn_tag {      \/* function call           *\/$/;"	s	union:Expn_tag::expnVal_tag
expnOp_tag	astDef.h	/^    struct expnOp_tag {      \/* operator                *\/$/;"	s	union:Expn_tag::expnVal_tag
expnP	parser.tab.c	/^        ExpnP expnP;$/;"	m	union:	file:
expnP	parser.tab.h	/^        ExpnP expnP;$/;"	m	union:
expnVal_tag	astDef.h	/^  union expnVal_tag {$/;"	u	struct:Expn_tag
expression	parser.y	/^expression      :  conjunction$/;"	l
factor	parser.y	/^factor          :  primary$/;"	l
fileOpen	main.c	/^static FILE * fileOpen( char * fileName, char * fileMode, $/;"	f	file:
finalizeArg	ast.c	/^void finalizeArg( ArgsP arg )$/;"	f
finalizeDecl	ast.c	/^void finalizeDecl( DeclP decl ) $/;"	f
finalizeExpn	ast.c	/^void finalizeExpn( ExpnP expn )$/;"	f
finalizeFParm	ast.c	/^void finalizeFParm( FparmP param )$/;"	f
finalizeLit	ast.c	/^void finalizeLit( LitObjP lit )$/;"	f
finalizeObject	ast.c	/^void finalizeObject( ObjectP obj ) $/;"	f
finalizeScope	ast.c	/^void finalizeScope( ScopeP scope )$/;"	f
finalizeStmt	ast.c	/^void finalizeStmt( StmtP stmt )$/;"	f
firstInstruction	machineDef.h	113;"	d
fname	astDef.h	/^  char*     fname;       \/* parameter name              *\/$/;"	m	struct:FParm_tag
fnext	astDef.h	/^  FparmP    fnext;       \/* next parameter              *\/$/;"	m	struct:FParm_tag
formatInstruction	machine.c	/^static int formatInstruction( int addr ) {$/;"	f	file:
foundResult	semantics.c	/^    BOOLEAN foundResult;$/;"	m	struct:commFlags_Tag	file:
fparmP	parser.tab.c	/^        FparmP fparmP;$/;"	m	union:	file:
fparmP	parser.tab.h	/^        FparmP fparmP;$/;"	m	union:
ftype	astDef.h	/^  DataType  ftype;       \/* parameter datatype          *\/$/;"	m	struct:FParm_tag
functionCall	parser.y	/^functionCall    :  IDENT '(' arguments ')'   $/;"	l
globalvarsVersion	globalvars.h	/^static const char globalvarsVersion[] = $/;"	v
identLeng	scanner.c	/^int	identLeng ;	\/* holds length of identifier 			*\/$/;"	v
if	parser.tab.c	/^  if (yychar == YYEMPTY)$/;"	f
if	parser.tab.c	/^  if (yydebug)$/;"	f
if	parser.tab.c	/^  if (yyerrstatus == 3)$/;"	f
ifstatement	parser.y	/^ifstatement     :  IF expression  THEN statements ELSE statements FI$/;"	l
inBlanks	astDump.c	/^static char inBlanks[ INDENT_STEP * INDENT_MAX + 1 ] ;$/;"	v	file:
indents	astDump.c	/^static char * indents[ INDENT_MAX + 1 ] ;$/;"	v	file:
initFlags	semantics.c	/^void initFlags( commFlagsP flags ) $/;"	f
initNeeded	astDump.c	/^static BOOLEAN initNeeded = TRUE ;$/;"	v	file:
input	parser.y	/^input           :  variable$/;"	l
inputFile	globalvars.h	/^EXTERN_GLOBALS FILE * inputFile ;$/;"	v
inputs	parser.y	/^inputs          :  input                 $/;"	l
insideFunc	semantics.c	/^    BOOLEAN insideFunc;     \/* whether we're in a function      *\/$/;"	m	struct:commFlags_Tag	file:
insideLoop	semantics.c	/^    BOOLEAN insideLoop;     \/* whether we're in a loop          *\/$/;"	m	struct:commFlags_Tag	file:
insideProc	semantics.c	/^    BOOLEAN insideProc;     \/* whether we're in a procedure     *\/$/;"	m	struct:commFlags_Tag	file:
instructionBuffer	machine.c	/^static char instructionBuffer[ 64 ] ;   \/* output from formatInstruction *\/$/;"	v	file:
instructionDump	machine.c	/^static void  instructionDump() {$/;"	f	file:
instructionLength	machineDef.h	/^EXTERN_MACHINE const unsigned char instructionLength[] $/;"	v
instructionNames	machineDef.h	/^EXTERN_MACHINE const char *instructionNames[]$/;"	v
intValue	scanner.c	/^int	intValue ;	\/* holds value of integer constants 		*\/$/;"	v
lastInstruction	machineDef.h	114;"	d
lexicLevel	symbol.c	/^static int lexicLevel;$/;"	v	file:
lexic_level	symbol.h	/^   int lexic_level;$/;"	m	struct:SymbTabEntryInfo_tag
line	astDef.h	/^  int line; \/* line number *\/$/;"	m	struct:Args_tag
line	astDef.h	/^  int line; \/* line number *\/$/;"	m	struct:Decl_tag
line	astDef.h	/^  int line; \/* line number *\/$/;"	m	struct:Expn_tag
line	astDef.h	/^  int line; \/* line number *\/$/;"	m	struct:FParm_tag
line	astDef.h	/^  int line; \/* line number *\/$/;"	m	struct:Scope_tag
line	astDef.h	/^  int line; \/* line number *\/$/;"	m	struct:Stmt_tag
line	globalvars.h	/^EXTERN_GLOBALS int line ;$/;"	v
litP	parser.tab.c	/^        LitObjP litP;$/;"	m	union:	file:
litP	parser.tab.h	/^        LitObjP litP;$/;"	m	union:
litValue_tag	astDef.h	/^  union litValue_tag {$/;"	u	struct:LitObj_tag
llEnclosingLoop	codegen.c	/^    int llEnclosingLoop; \/* lexic level of enclosing loop *\/$/;"	m	struct:Flags_tag	file:
llEnclosingRoutine	codegen.c	/^    int llEnclosingRoutine; \/* lexic level of enclosing routine's body *\/$/;"	m	struct:Flags_tag	file:
ltype	astDef.h	/^  DataType  ltype;  \/* type of literal stored           *\/$/;"	m	struct:LitObj_tag
lvalue	astDef.h	/^  } lvalue;     \/* value of the literal                 *\/$/;"	m	struct:LitObj_tag
machineDefVersion	machineDef.h	/^static const char machineDefVersion[] = $/;"	v
machineExecute	machine.c	/^void machineExecute() {$/;"	f
machineInitialize	machine.c	/^void machineInitialize() {$/;"	f
machineInterfaceVersion	machine.h	/^static const char machineInterfaceVersion[] = $/;"	v
machineVersion	machine.c	/^static const char machineVersion[] = $/;"	v	file:
main	astTest.c	/^int main( int argc , char *argv[] ){$/;"	f
main	main.c	/^int main( int argc , char *argv[] ){$/;"	f
main	scanner.c	/^int main()$/;"	f
mainVersion	main.c	/^static const char mainVersion[] = $/;"	v	file:
memory	machineDef.h	/^EXTERN_MACHINE MEMORYWORD memory[ MEMORYSIZE ] ;$/;"	v
mkArg_expn	ast.c	/^ArgsP mkArg_expn(ExpnP expr)$/;"	f
mkArg_list_args	ast.c	/^ArgsP mkArg_list_args(ArgsP args, ArgsP arg)$/;"	f
mkArg_list_expn	ast.c	/^ArgsP mkArg_list_expn(ArgsP arg, ExpnP expr)$/;"	f
mkArg_skip	ast.c	/^ArgsP mkArg_skip(int linenum)$/;"	f
mkArg_str	ast.c	/^ArgsP mkArg_str(tokentype text, int linenum)$/;"	f
mkDecl_arr	ast.c	/^DeclP mkDecl_arr(DeclP decl, tokentype size)$/;"	f
mkDecl_body	ast.c	/^DeclP mkDecl_body(FparmP params, ScopeP scope, int linenum)$/;"	f
mkDecl_func	ast.c	/^DeclP mkDecl_func(DeclP decl, DeclP body)$/;"	f
mkDecl_list	ast.c	/^ObjectP mkDecl_list(ObjectP decl_list, DeclP decl)$/;"	f
mkDecl_proc	ast.c	/^DeclP mkDecl_proc(tokentype ident, DeclP body)$/;"	f
mkDecl_scalar	ast.c	/^DeclP mkDecl_scalar(DeclP decl)$/;"	f
mkDecl_var_ident	ast.c	/^DeclP mkDecl_var_ident(DeclP decl, tokentype ident)$/;"	f
mkDecl_var_type	ast.c	/^DeclP mkDecl_var_type(DataType dataType, int linenum)$/;"	f
mkExpn_cond	ast.c	/^ExpnP mkExpn_cond(ExpnP cond, ExpnP mid, ExpnP right, int linenum)$/;"	f
mkExpn_const	ast.c	/^ExpnP mkExpn_const(LitObjP lit, int linenum)$/;"	f
mkExpn_func	ast.c	/^ExpnP mkExpn_func(tokentype ident, ArgsP args, int linenum)$/;"	f
mkExpn_oper	ast.c	/^ExpnP mkExpn_oper(ExpnP left, OperType operType, ExpnP right, int linenum)$/;"	f
mkExpn_var	ast.c	/^ExpnP mkExpn_var(tokentype ident, int linenum)$/;"	f
mkExpn_var_arr	ast.c	/^ExpnP mkExpn_var_arr(tokentype ident, ExpnP expr, int linenum)$/;"	f
mkFparm_list	ast.c	/^FparmP mkFparm_list(FparmP parms, DeclP decl)$/;"	f
mkLit	ast.c	/^LitObjP mkLit(DataType dataType, tokentype constant)$/;"	f
mkLit_bool	ast.c	/^LitObjP mkLit_bool(DataType dataType, int boolValue)$/;"	f
mkProgram	ast.c	/^ObjectP mkProgram(ScopeP scope) $/;"	f
mkScope	ast.c	/^ScopeP mkScope(ObjectP decls, ObjectP stmts, int linenum) $/;"	f
mkStmt_assign	ast.c	/^StmtP mkStmt_assign(ExpnP var, ExpnP expr, int linenum)$/;"	f
mkStmt_do	ast.c	/^StmtP mkStmt_do(ObjectP stmts, ExpnP expr, int linenum)$/;"	f
mkStmt_exit	ast.c	/^StmtP mkStmt_exit(int linenum)$/;"	f
mkStmt_get	ast.c	/^StmtP mkStmt_get(ArgsP args, int linenum)$/;"	f
mkStmt_if	ast.c	/^StmtP mkStmt_if(ExpnP expr, ObjectP then_stmts, ObjectP else_stmts, int$/;"	f
mkStmt_list	ast.c	/^ObjectP mkStmt_list(ObjectP stmt_list, StmtP stmt)$/;"	f
mkStmt_proc	ast.c	/^StmtP mkStmt_proc(tokentype ident, ArgsP args, int linenum)$/;"	f
mkStmt_put	ast.c	/^StmtP mkStmt_put(ArgsP args, int linenum)$/;"	f
mkStmt_result	ast.c	/^StmtP mkStmt_result(ExpnP expr, int linenum)$/;"	f
mkStmt_return	ast.c	/^StmtP mkStmt_return(int linenum)$/;"	f
mkStmt_scope	ast.c	/^StmtP mkStmt_scope(ScopeP scope, int linenum)$/;"	f
mkStmt_while	ast.c	/^StmtP mkStmt_while(ExpnP expr, ObjectP stmts, int linenum)$/;"	f
name	symbol.h	/^   char *name;$/;"	m	struct:SymbTabEntryInfo_tag
negation	parser.y	/^negation        :  compareExpr$/;"	l
num	astDef.h	/^    int   num;     \/* value for numeric constant,       *\/$/;"	m	union:LitObj_tag::litValue_tag
num	common.h	/^    int num;    \/* integer constants *\/ $/;"	m	union:
numArgs	semantics.c	/^int numArgs( ArgsP args )$/;"	f
numParms	ast.c	/^int numParms( FparmP parms )$/;"	f
number	parser.tab.c	/^        int number;$/;"	m	union:	file:
number	parser.tab.h	/^        int number;$/;"	m	union:
objectP	parser.tab.c	/^        ObjectP objectP; $/;"	m	union:	file:
objectP	parser.tab.h	/^        ObjectP objectP; $/;"	m	union:
objectValue_tag	astDef.h	/^  union  objectValue_tag {$/;"	u	struct:Object_tag
onext	astDef.h	/^  ObjectP  onext ;      \/* pointer to next related object *\/$/;"	m	struct:Object_tag
operNames	astDump.c	/^char * operNames[] = {	"?", "&", "|", "!", 	          \/* unknown, boolean *\/$/;"	v
optDeclarations	parser.y	/^optDeclarations :  declarations$/;"	l
orderNumber	symbol.c	/^static int orderNumber;$/;"	v	file:
order_number	symbol.h	/^   int order_number;$/;"	m	struct:SymbTabEntryInfo_tag
otype	astDef.h	/^  ObjType  otype;       \/*  type of this object         *\/$/;"	m	struct:Object_tag
output	parser.y	/^output          :  expression$/;"	l
outputFile	globalvars.h	/^EXTERN_GLOBALS FILE * outputFile ;$/;"	v
outputs	parser.y	/^outputs         :  output    $/;"	l
ovalue	astDef.h	/^  } ovalue ;            \/* value of the object          *\/$/;"	m	struct:Object_tag
parameters	parser.y	/^parameters      :  typeAndIdent$/;"	l
parseTree	globalvars.h	/^EXTERN_GLOBALS  ASTtype parseTree ;$/;"	v
parseVersion	parser.tab.c	/^static char parseVersion[] = $/;"	v	file:
pname	astDef.h	/^  char*     pname;  \/* procedure name *\/$/;"	m	struct:Stmt_tag
primary	parser.y	/^primary         :  '('     expression      ')'$/;"	l
printArgs	astDump.c	/^static void printArgs( const ArgsP args , int indn ) {$/;"	f	file:
printDecl	astDump.c	/^static void printDecl(DeclP decl, int indn ) {$/;"	f	file:
printExpn	astDump.c	/^static void printExpn(const ExpnP expn, int indn ) {$/;"	f	file:
printExpnTree	astDump.c	/^static void printExpnTree(const ExpnP expn , int indn ) {$/;"	f	file:
printLiteral	astDump.c	/^static void printLiteral(LitObj lit ) {$/;"	f	file:
printObject	astDump.c	/^static void printObject(const ObjectP tree, int indn ) {$/;"	f	file:
printScope	astDump.c	/^static void printScope(ScopeP scope, int indn ) {$/;"	f	file:
printStmt	astDump.c	/^static void printStmt(const StmtP stmt, int indn ) {$/;"	f	file:
procStatement	parser.y	/^procStatement   :  IDENT$/;"	l
program	parser.y	/^program         : scope$/;"	l
rangeCheck	machine.c	246;"	d	file:
resultBackpatchHead	codegen.c	/^    int resultBackpatchHead;$/;"	m	struct:Flags_tag	file:
returnBackpatchHead	codegen.c	/^    int returnBackpatchHead;$/;"	m	struct:Flags_tag	file:
returnType	semantics.c	/^    DataType returnType;    \/* return type of the function      *\/$/;"	m	struct:commFlags_Tag	file:
reverse_arg_list	ast.c	/^void reverse_arg_list (ArgsP * list) $/;"	f
reverse_obj_list	ast.c	/^void reverse_obj_list (ObjectP * list) $/;"	f
reverse_params_list	ast.c	/^void reverse_params_list (FparmP * list) $/;"	f
routineBody	parser.y	/^routineBody     :  '(' parameters ')' ':' scope $/;"	l
runError	machine.c	/^static void runError( char *msg , int pc, int msp, int mlp ){$/;"	f	file:
runInputFile	globalvars.h	/^EXTERN_GLOBALS  FILE * runInputFile ;$/;"	v
runTest	astTest.c	/^void runTest(char * desc, int (*test)()) $/;"	f
sargs	astDef.h	/^  ArgsP         sargs ;         \/* related arguments    *\/$/;"	m	struct:Stmt_tag
scbody	astDef.h	/^  ObjectP       scbody ;        \/* body of this scope   *\/$/;"	m	struct:Scope_tag
scope	astDef.h	/^        ScopeP scope ;  \/* scope                *\/$/;"	m	union:Object_tag::objectValue_tag
scope	parser.y	/^scope           :  '{' optDeclarations statements '}'$/;"	l
scopeP	parser.tab.c	/^        ScopeP scopeP;$/;"	m	union:	file:
scopeP	parser.tab.h	/^        ScopeP scopeP;$/;"	m	union:
scparent	astDef.h	/^  ScopeP        scparent ;      \/* containing scope     *\/$/;"	m	struct:Scope_tag
semanticsCheck	semantics.c	/^void semanticsCheck( ASTtype tree )$/;"	f
semanticsFinalize	semantics.c	/^void semanticsFinalize( ){$/;"	f
semanticsInitialize	semantics.c	/^void semanticsInitialize( ) {$/;"	f
semanticsInterfaceVersion	semantics.h	/^static const char semanticsInterfaceVersion[] = $/;"	v
semanticsVersion	semantics.c	/^static const char semanticsVersion[] $/;"	v	file:
sexpn1	astDef.h	/^  ExpnP         sexpn1, sexpn2 ;\/* related expressions  *\/$/;"	m	struct:Stmt_tag
sexpn2	astDef.h	/^  ExpnP         sexpn1, sexpn2 ;\/* related expressions  *\/$/;"	m	struct:Stmt_tag
sllevel	symbol.c	/^    int sllevel;$/;"	m	struct:SymbTabEntry_tag	file:
sname	symbol.c	/^    char *sname;    \/* symbol name *\/    $/;"	m	struct:SymbTabEntry_tag	file:
sonumber	symbol.c	/^    int sonumber;$/;"	m	struct:SymbTabEntry_tag	file:
sscope	astDef.h	/^  ScopeP        sscope ;  \/* related scope (if any)     *\/$/;"	m	struct:Stmt_tag
sstmt1	astDef.h	/^  ObjectP       sstmt1, sstmt2 ; \/* related statements  *\/$/;"	m	struct:Stmt_tag
sstmt2	astDef.h	/^  ObjectP       sstmt1, sstmt2 ; \/* related statements  *\/$/;"	m	struct:Stmt_tag
startMLP	globalvars.h	/^EXTERN_GLOBALS  int startMLP ;$/;"	v
startMSP	globalvars.h	/^EXTERN_GLOBALS  int startMSP ;$/;"	v
startPC	globalvars.h	/^EXTERN_GLOBALS int startPC ;$/;"	v
statement	parser.y	/^statement       :  variable  '='  expression$/;"	l
statements	parser.y	/^statements      :  statement$/;"	l
stmt	astDef.h	/^        StmtP  stmt ;   \/* statement            *\/$/;"	m	union:Object_tag::objectValue_tag
stmtNames	astDump.c	/^char * stmtNames[] = { "unknown", "assignment", "if", "if+else", "while", $/;"	v
stmtP	parser.tab.c	/^        StmtP stmtP;$/;"	m	union:	file:
stmtP	parser.tab.h	/^        StmtP stmtP;$/;"	m	union:
str	astDef.h	/^    char* str;     \/* value for string constant         *\/$/;"	m	union:LitObj_tag::litValue_tag
str	common.h	/^    char* str;   \/* text values *\/$/;"	m	union:
str	parser.tab.c	/^        char *str;$/;"	m	union:	file:
str	parser.tab.h	/^        char *str;$/;"	m	union:
stype	astDef.h	/^  StmtType      stype ;         \/* statement type       *\/$/;"	m	struct:Stmt_tag
suppressExecution	globalvars.h	/^EXTERN_GLOBALS BOOLEAN  suppressExecution ;$/;"	v
symbolAddDecl	symbol.c	/^void symbolAddDecl(DeclP declP)$/;"	f
symbolAddFparm	symbol.c	/^void symbolAddFparm( FparmP dfparm )$/;"	f
symbolDumpTable	symbol.c	/^void symbolDumpTable(FILE *stream)$/;"	f
symbolDumpTableEntry	symbol.c	/^void symbolDumpTableEntry(FILE *stream, SymbTabEntryInfoP entry, int entryIndex)$/;"	f
symbolEnterScope	symbol.c	/^void symbolEnterScope(void)$/;"	f
symbolExitScope	symbol.c	/^void symbolExitScope(void)$/;"	f
symbolFinalize	symbol.c	/^void symbolFinalize(void)$/;"	f
symbolInitialize	symbol.c	/^void symbolInitialize(void) $/;"	f
symbolInterfaceVersion	symbol.h	/^static const char symbolInterfaceVersion[]$/;"	v
symbolLexicLevel	symbol.c	/^int symbolLexicLevel(void) $/;"	f
symbolLookup	symbol.c	/^BOOLEAN symbolLookup(char *sname, SymbTabEntryInfoP sentryinfo)$/;"	f
symbolVersion	symbol.c	/^static const char symbolVersion[] = $/;"	v	file:
term	parser.y	/^term            :  factor$/;"	l
testMkDecl_list	astTest.c	/^int testMkDecl_list(void) $/;"	f
testMkExpn_oper_binary	astTest.c	/^int testMkExpn_oper_binary(void) {$/;"	f
testMkExpn_oper_unary	astTest.c	/^int testMkExpn_oper_unary(void) $/;"	f
testMkProgram	astTest.c	/^int testMkProgram(void) $/;"	f
testMkStmt_list	astTest.c	/^int testMkStmt_list(void) $/;"	f
test_symbolTable	astTest.c	/^void test_symbolTable()$/;"	f
textLeng	scanner.c	/^int	textLeng ;	\/* hold length of string constant (text) 	*\/$/;"	v
token	parser.tab.c	/^        tokentype token;$/;"	m	union:	file:
token	parser.tab.h	/^        tokentype token;$/;"	m	union:
tokentype	common.h	/^} tokentype;$/;"	t
top	symbol.c	/^static int top;$/;"	v	file:
traceAST	globalvars.h	/^EXTERN_GLOBALS  BOOLEAN  traceAST ;$/;"	v
traceCodeGen	globalvars.h	/^EXTERN_GLOBALS  BOOLEAN  traceCodeGen ;		$/;"	v
traceExecution	globalvars.h	/^EXTERN_GLOBALS BOOLEAN  traceExecution ;$/;"	v
traceFile	globalvars.h	/^EXTERN_GLOBALS  FILE * traceFile ;$/;"	v
traceParse	globalvars.h	158;"	d
traceSemantics	globalvars.h	/^EXTERN_GLOBALS  BOOLEAN  traceSemantics ;$/;"	v
traceSource	globalvars.h	/^EXTERN_GLOBALS BOOLEAN traceSource ;$/;"	v
traceSymbols	globalvars.h	/^EXTERN_GLOBALS  BOOLEAN  traceSymbols ;$/;"	v
traceTokens	globalvars.h	/^EXTERN_GLOBALS BOOLEAN traceTokens ;	$/;"	v
type	parser.y	/^type            :  INT$/;"	l
typeAndIdent	parser.y	/^typeAndIdent    :  type IDENT $/;"	l
typeNames	astDump.c	/^char * typeNames[] = { "unknown", "boolean", "int", "text", "void" };$/;"	v
unput	scanner.c	136;"	d	file:
variable	parser.y	/^variable        :  IDENT           \/* Could be function call *\/$/;"	l
yy_accept	scanner.c	/^static yyconst long int yy_accept[86] =$/;"	v	file:
yy_at_bol	scanner.c	/^	int yy_at_bol;$/;"	m	struct:yy_buffer_state	file:
yy_base	scanner.c	/^static yyconst long int yy_base[88] =$/;"	v	file:
yy_buf_pos	scanner.c	/^	char *yy_buf_pos;		\/* current position in input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_size	scanner.c	/^	yy_size_t yy_buf_size;$/;"	m	struct:yy_buffer_state	file:
yy_buffer_state	scanner.c	/^struct yy_buffer_state$/;"	s	file:
yy_buffer_status	scanner.c	/^	int yy_buffer_status;$/;"	m	struct:yy_buffer_state	file:
yy_c_buf_p	scanner.c	/^static char *yy_c_buf_p = (char *) 0;$/;"	v	file:
yy_ch_buf	scanner.c	/^	char *yy_ch_buf;		\/* input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_chk	scanner.c	/^static yyconst long int yy_chk[177] =$/;"	v	file:
yy_create_buffer	scanner.c	/^YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )$/;"	f
yy_current_buffer	scanner.c	/^static YY_BUFFER_STATE yy_current_buffer = 0;$/;"	v	file:
yy_def	scanner.c	/^static yyconst long int yy_def[88] =$/;"	v	file:
yy_delete_buffer	scanner.c	/^void yy_delete_buffer( YY_BUFFER_STATE b )$/;"	f
yy_did_buffer_switch_on_eof	scanner.c	/^static int yy_did_buffer_switch_on_eof;$/;"	v	file:
yy_ec	scanner.c	/^static yyconst int yy_ec[256] =$/;"	v	file:
yy_fatal_error	scanner.c	/^static void yy_fatal_error( yyconst char msg[] )$/;"	f	file:
yy_fill_buffer	scanner.c	/^	int yy_fill_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_flex_alloc	scanner.c	/^static void *yy_flex_alloc( yy_size_t size )$/;"	f	file:
yy_flex_free	scanner.c	/^static void yy_flex_free( void *ptr )$/;"	f	file:
yy_flex_realloc	scanner.c	/^static void *yy_flex_realloc( void *ptr, yy_size_t size )$/;"	f	file:
yy_flex_strlen	scanner.c	/^static int yy_flex_strlen( yyconst char *s )$/;"	f	file:
yy_flex_strncpy	scanner.c	/^static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )$/;"	f	file:
yy_flush_buffer	scanner.c	/^void yy_flush_buffer( YY_BUFFER_STATE b )$/;"	f
yy_get_next_buffer	scanner.c	/^static int yy_get_next_buffer()$/;"	f	file:
yy_get_previous_state	scanner.c	/^static yy_state_type yy_get_previous_state()$/;"	f	file:
yy_hold_char	scanner.c	/^static char yy_hold_char;$/;"	v	file:
yy_init	scanner.c	/^static int yy_init = 1;		\/* whether we need to initialize *\/$/;"	v	file:
yy_init_buffer	scanner.c	/^void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )$/;"	f
yy_input_file	scanner.c	/^	FILE *yy_input_file;$/;"	m	struct:yy_buffer_state	file:
yy_is_interactive	scanner.c	/^	int yy_is_interactive;$/;"	m	struct:yy_buffer_state	file:
yy_is_our_buffer	scanner.c	/^	int yy_is_our_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_last_accepting_cpos	scanner.c	/^static char *yy_last_accepting_cpos;$/;"	v	file:
yy_last_accepting_state	scanner.c	/^static yy_state_type yy_last_accepting_state;$/;"	v	file:
yy_load_buffer_state	scanner.c	/^void yy_load_buffer_state( void )$/;"	f
yy_n_chars	scanner.c	/^	int yy_n_chars;$/;"	m	struct:yy_buffer_state	file:
yy_n_chars	scanner.c	/^static int yy_n_chars;		\/* number of characters read into yy_ch_buf *\/$/;"	v	file:
yy_new_buffer	scanner.c	247;"	d	file:
yy_nxt	scanner.c	/^static yyconst long int yy_nxt[177] =$/;"	v	file:
yy_pop_state	scanner.c	/^static void yy_pop_state()$/;"	f	file:
yy_push_state	scanner.c	/^static void yy_push_state( int new_state )$/;"	f	file:
yy_scan_buffer	scanner.c	/^YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )$/;"	f
yy_scan_bytes	scanner.c	/^YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )$/;"	f
yy_scan_string	scanner.c	/^YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )$/;"	f
yy_set_bol	scanner.c	256;"	d	file:
yy_set_interactive	scanner.c	249;"	d	file:
yy_size_t	scanner.c	/^typedef unsigned int yy_size_t;$/;"	t	file:
yy_start	scanner.c	/^static int yy_start = 0;	\/* start state number *\/$/;"	v	file:
yy_start_stack	scanner.c	/^static int *yy_start_stack = 0;$/;"	v	file:
yy_start_stack_depth	scanner.c	/^static int yy_start_stack_depth = 0;$/;"	v	file:
yy_start_stack_ptr	scanner.c	/^static int yy_start_stack_ptr = 0;$/;"	v	file:
yy_state_type	scanner.c	/^typedef int yy_state_type;$/;"	t	file:
yy_switch_to_buffer	scanner.c	/^void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )$/;"	f
yy_top_state	scanner.c	/^static int yy_top_state()$/;"	f	file:
yy_try_NUL_trans	scanner.c	/^static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )$/;"	f	file:
yyalloc	parser.tab.c	/^union yyalloc$/;"	u	file:
yybackup	parser.tab.c	/^  goto yybackup;$/;"	v
yycheck	parser.tab.c	/^static const short yycheck[] =$/;"	v	file:
yyclearin	parser.tab.c	506;"	d	file:
yyconst	scanner.c	54;"	d	file:
yyconst	scanner.c	56;"	d	file:
yydebug	parser.tab.c	/^int yydebug;$/;"	v
yydefact	parser.tab.c	/^static const short yydefact[] =$/;"	v	file:
yydefault	parser.tab.c	/^    goto yydefault;$/;"	v
yydefgoto	parser.tab.c	/^static const short yydefgoto[] =$/;"	v	file:
yyerrdefault	parser.tab.c	/^    goto yyerrdefault;$/;"	v
yyerrhandle	parser.tab.c	/^  goto yyerrhandle;$/;"	v
yyerrlab1	parser.tab.c	/^  goto yyerrlab1;$/;"	v
yyerrok	parser.tab.c	505;"	d	file:
yyin	scanner.c	/^FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;$/;"	v
yyinput	scanner.c	/^static int yyinput()$/;"	f	file:
yyinput	scanner.c	443;"	d	file:
yyleng	scanner.c	/^int yyleng;$/;"	v
yyless	scanner.c	125;"	d	file:
yyless	scanner.c	1778;"	d	file:
yyless	scanner.c	1779;"	d	file:
yyls	parser.tab.c	/^  YYLTYPE yyls;$/;"	m	union:yyalloc	file:
yymore	scanner.c	412;"	d	file:
yyn	parser.tab.c	/^  yyn = yypact[yystate];$/;"	v
yynewstate	parser.tab.c	/^  goto yynewstate;$/;"	v
yyout	scanner.c	/^FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;$/;"	v
yypact	parser.tab.c	/^static const short yypact[] =$/;"	v	file:
yyparse	parser.tab.c	/^yyparse (YYPARSE_PARAM_ARG)$/;"	f
yypgoto	parser.tab.c	/^static const short yypgoto[] =$/;"	v	file:
yyprhs	parser.tab.c	/^static const short yyprhs[] =$/;"	v	file:
yyr1	parser.tab.c	/^static const short yyr1[] =$/;"	v	file:
yyr2	parser.tab.c	/^static const short yyr2[] =$/;"	v	file:
yyrestart	scanner.c	/^void yyrestart( FILE *input_file )$/;"	f
yyrhs	parser.tab.c	/^static const short yyrhs[] =$/;"	v	file:
yyrline	parser.tab.c	/^static const short yyrline[] =$/;"	v	file:
yyss	parser.tab.c	/^  short yyss;$/;"	m	union:yyalloc	file:
yystate	parser.tab.c	/^    yystate = yydefgoto[yyn - YYNTBASE];$/;"	v
yystpcpy	parser.tab.c	/^yystpcpy (char *yydest, const char *yysrc)$/;"	f	file:
yystpcpy	parser.tab.c	640;"	d	file:
yystrlen	parser.tab.c	/^yystrlen (const char *yystr)$/;"	f	file:
yystrlen	parser.tab.c	617;"	d	file:
yystype	parser.tab.c	/^        } yystype;$/;"	t	file:
yystype	parser.tab.h	/^        } yystype;$/;"	t
yytable	parser.tab.c	/^static const short yytable[] =$/;"	v	file:
yyterminate	scanner.c	582;"	d	file:
yytext	scanner.c	/^char *yytext;$/;"	v
yytext_ptr	scanner.c	269;"	d	file:
yytname	parser.tab.c	/^static const char *const yytname[] =$/;"	v	file:
yytranslate	parser.tab.c	/^static const char yytranslate[] =$/;"	v	file:
yyunput	scanner.c	/^static void yyunput( int c, register char *yy_bp )$/;"	f	file:
yyvs	parser.tab.c	/^  YYSTYPE yyvs;$/;"	m	union:yyalloc	file:
